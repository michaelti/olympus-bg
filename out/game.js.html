<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: game.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: game.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//@ts-check
const { Random, MersenneTwister19937 } = require("random-js");
const random = new Random(MersenneTwister19937.autoSeed());

/** Enum for the player ID
 * @readonly
 * @enum {number}
 */
const Player = Object.freeze({
    neither: 0,
    white: 1,
    black: -1,
});

const TurnMessage = Object.freeze({
    valid: 1,
    validZero: 2,
    invalid: 0,
    invalidMoreMoves: -1,
    invalidLongerMove: -2,
});

// Variant of backgammon
exports.Variant = Object.freeze({
    portes: 1,
    plakoto: 2,
    fevga: 3,
});

/**
 * Clamps a number in range 0–25
 * @param {number} to - the destination of a move
 * @returns {number} the clamped number
 */
exports.clamp = (to) => (to &lt; 0 ? 0 : to > 25 ? 25 : to);

/**
 * Calculates the shortest distance between two pips on the board
 * @param {number} from - the first pip (1-24)
 * @param {number} to - the second pip (1-24)
 * @returns {number} the distance between the first and second (0-12)
 */
const pipDistance = (from, to) => {
    const dist = Math.abs(to - from);
    return dist &lt;= 12 ? dist : 24 - dist;
};
/**
 * @name Move
 * @param {number} from 
 * @param {number} to 
 */
exports.Move = (from, to) => ({ from, to });

/**
 * Reverses the values of the from and to properties of a Move object
 * @param {{ from: any, to: any }} move
 */
exports.reverseMove = (move) => ({ from: move.to, to: move.from });

exports.Board = () => ({
    turn: null,
    winner: null,
    off: { [Player.white]: 0, [Player.black]: 0 },
    pips: new Array(26).fill().map(() => Pip()),
    diceRolled: new Array(2),
    dice: new Array(2),
    recentMove: {},
    possibleTurns: null,
    maxTurnLength: 0,
    turnValidity: TurnMessage.invalid,

    publicProperties() {
        return {
            turn: this.turn,
            winner: this.winner,
            off: this.off,
            pips: this.pips,
            diceRolled: this.diceRolled,
            dice: this.dice,
            recentMove: this.recentMove,
            turnValidity: this.turnValidity,
            // Portes properties
            bar: this.bar,
            // Fevga properties
            state: this.state,
        };
    },

    rollDice() {
        // Roll a 6-sided die, 2 times
        this.diceRolled = random.dice(6, 2);

        // Doubles
        if (this.diceRolled[0] === this.diceRolled[1])
            this.diceRolled = this.diceRolled.concat(this.diceRolled);

        // Sort smallest to largest
        this.dice = [...this.diceRolled].sort((a, b) => a - b);

        this.maxTurnLength = 0;
        this.turnValidity = TurnMessage.invalid;
        try {
            this.possibleTurns = this.allPossibleTurns();
            for (const turn of this.possibleTurns) {
                if (turn.length > this.maxTurnLength) this.maxTurnLength = turn.length;
            }
            if (this.maxTurnLength === 0) this.turnValidity = TurnMessage.validZero;
        } catch (four) {
            // Code optimization when there's a possible 4-move turn
            this.maxTurnLength = 4;
        }
    },

    // Returns the player who's turn it ISN'T
    otherPlayer(player = this.turn) {
        if (player === Player.black) return Player.white;
        if (player === Player.white) return Player.black;
        return Player.neither;
    },

    /**
     * Checks if the board in a state where either player has won
     * @returns { 0 | 1 | 2 } 0 if the game is not over; 1 or 2 representing the number of points won
     */
    isGameOver() {
        if (this.off[this.turn] === 15) {
            this.winner = this.turn;
            this.turn = Player.neither;
            // if the other player has born off 0 checkers, return 2 points
            return this.off[this.otherPlayer(this.winner)] === 0 ? 2 : 1;
        }
        return 0;
    },

    /**
     * Validates a turn of 0–4 moves
     * @param {Object[]} moves - an array of Move objects (can be empty)
     * @returns {number} of type TurnMessage indicating if the turn is valid
     */
    turnValidator(moves) {
        // Validate turn length. Players must make as many moves as possible
        if (this.maxTurnLength !== moves.length) {
            // unless they have 14 checkers off and are bearing off their 15th (final)
            if (!(this.off[this.turn] === 14 &amp;&amp; (moves[0].to === 0 || moves[0].to === 25)))
                return TurnMessage.invalidMoreMoves;
        }
        // Validate single move turn uses the largest dice value possible
        if (this.maxTurnLength === 1 &amp;&amp; this.dice.length === 2) {
            // if the supplied move matches the smaller dice
            // then check if there's a possible move with the larger dice
            if (pipDistance(moves[0].from, moves[0].to) === this.dice[0]) {
                for (const turn of this.possibleTurns) {
                    if (pipDistance(turn[0].from, turn[0].to) === this.dice[1])
                        return TurnMessage.invalidLongerMove;
                }
            }
        }
        return TurnMessage.valid;
    },

    /** @abstract */
    allPossibleTurns: () => null,
});

const Pip = (size = 0, owner = Player.neither) => ({
    size: size,
    top: owner,
    bot: owner,
});

const rollDie = () => random.die(6);

exports.Player = Player;
exports.TurnMessage = TurnMessage;
exports.pipDistance = pipDistance;
exports.Pip = Pip;
exports.rollDie = rollDie;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#allPossibleTurns">allPossibleTurns</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#isGameOver">isGameOver</a></li><li><a href="global.html#Move">Move</a></li><li><a href="global.html#pipDistance">pipDistance</a></li><li><a href="global.html#Player">Player</a></li><li><a href="global.html#reverseMove">reverseMove</a></li><li><a href="global.html#turnValidator">turnValidator</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Sat Jan 16 2021 22:41:08 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
